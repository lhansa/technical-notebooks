{
  "hash": "0c9c93b5657354ce20518ee06e8e79c1",
  "result": {
    "markdown": "---\ntitle: \"Cómo visualizar cualquier conjunto de datos en 2 dimensiones\"\ndescription: \"Uso de t-SNE para visualizar en 2 dimensiones un conjunto de datos, independientemente de cuántas variables tenga \"\ndescription-meta: \"Uso de t-SNE para visualizar en 2 dimensiones\"\nauthor: \"Leonardo Hansa\"\ndate: \"2023-09-30\"\ncategories: [datos]\nexecute: \n  echo: true\nfreeze: auto\n---\n\n::: {.cell labs='data'}\n\n:::\n\n\nEn este post te muestro cómo puedes usar el algoritmo t-SNE con R para visualizar datos de grandes dimensiones en solo 2. \n\nUtilizo el conjunto de datos MNIST, que tiene 60.000 observaciones de cifras escritas a mano, determinadas por una malla de 28x28 con un indicador del nivel de gris que hay en cada píxel del mallado. \n\nCada una de las observaciones viene dada por el nivel de gris que hay en cada píxel, o sea, por 784 variables.\n\nSi quisieras hacer una visualización de cómo se distribuyen tus observaciones en todas esas variables... pues simplemente no podrías. \n\nt-SNE te lo proyecta todo en 2 dimensiones, para que puedas luego visualizarlo.\n\n## Preparación de datos\n\nHe hecho un poco de trampa y los datos ya los tengo preparados. Pero vamos, que voy a usar los datos que tienes si ejecutas `keras::dataset_mnist()`. Concretamente la parte de entrenamiento. \n\nY bueno, tendrás que ejecutar eso y configurarlo bien, porque menuda aventura: Python y sus entornos virtuales. \n\nAparte, usaré librerías de tidyverse para dar forma a los datos.\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\nlibrary(tidyr)\nlibrary(purrr)\nlibrary(ggplot2)\nlibrary(Rtsne)\n\nggplot2::theme_set(ggplot2::theme_light())\n```\n:::\n\n\n\nPara lo que quiero hacer no necesito las 60.000 observaciones que hay, así que me quedo con las 1000 primeras.\n\n\n\n::: {.cell labs='prep-data'}\n\n```{.r .cell-code}\nmax_number <- 1000\n# map_dfr(seq_len(dim(mnist)[1]), function(i) {\ndata <- map_dfr(seq_len(max_number), function(i) {\n  data_aux <- mnist[i, 1:28, 1:28] \n  colnames(data_aux) <- paste0(\"Y\", 1:28)\n  \n  data_aux |> \n    as_tibble() |> \n    mutate(x = paste0(\"X\", 1:28)) |> \n    pivot_longer(-x, names_to = \"y\") |> \n    unite(\"variable\", x, y) |> \n    mutate(case = i)  \n})\n\ndata <- data |> \n  pivot_wider(names_from = variable, values_from = value)\n\ndim(data)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1000  785\n```\n:::\n:::\n\n\nLa columna extra es la que me indica que son observaciones diferentes. \n\n## Cómo aplicas t-SNE\n\nMira, sinceramente ni idea. \n\nO sea, tú ejecuta `Rtsne()` sobre tu _data frame_ y surge la magia. \n\n\n::: {.cell labs='tsne'}\n\n```{.r .cell-code}\ntsne_fit <- Rtsne(data)\ndim(tsne_fit$Y)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1000    2\n```\n:::\n:::\n\n\n\n## Cómo puedes visualizar t-SNE\n\nRecupero de los datos originales la etiqueta del número que se supone que representa cada mallado. Como estoy trabajando solo con los 1.000 primeros, me quedo solo con esos. \n\nEn el gráfico muestro cómo se distribuyen los puntos y los coloreo en función de si son un 0, 1, 2, 3, etc.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_to_plot <- as_tibble(tsne_fit$Y)\ndf_to_plot$label <- as.factor(number_labels[1:max_number])\n\nggplot(df_to_plot) + \n  geom_point(aes(x = V1, y = V2, col = label)) + \n  labs(\n    title = \"t-SNE applied to MNIST dataset\",\n    subtitle = sprintf(\"Sample of first %i elements\", max_number), \n    caption = \"Source: keras::dataset_mnist()\"\n  )\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}