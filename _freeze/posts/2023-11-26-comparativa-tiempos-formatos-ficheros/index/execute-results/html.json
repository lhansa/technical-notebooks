{
  "hash": "ee20f3148480bd9426b17ab3356df48d",
  "result": {
    "markdown": "---\ntitle: \"¿Qué formato de datos es más rápido de leer y escribir?\"\ndescription: \"Experimentos para comparar tiempos de ejecución en lectura y escritura de distintos ficheros de datos con R y Python\"\ndescription-meta: \"Experimentos para comparar tiempos de ejecución en lectura y escritura de distintos ficheros de datos con R y Python\"\nauthor: \"Leonardo Hansa\"\ndate: \"2023-11-26\"\ncategories: [datos]\nexecute: \n  echo: false\nfreeze: auto\n---\n\n\nHe leído [aquí](https://www.blog.dailydoseofds.com/p/the-most-overlooked-source-of-optimization) una comparativa entre tiempos de ejecución de lectura y escritura de varios tipos de ficheros de datos. Con Python. \n\nY he pensado: \n\n> Lo voy a hacer yo con R. \n\n\n::: {.cell}\n\n:::\n\n\nHe creado dos data frames, a los que he llamado `df_numeric` y `df_mixed`. Ambos tienen un millón de filas y 20 columnas. \n\n- `df_numeric` tiene todas las columnas numéricas\n- `df_mixed` tiene 10 columnas de tipo `character` y otras 10 de tipo `numeric`. \n\n\n::: {.cell}\n\n:::\n\n\nY lo que quiero es ver cuánto tardo en guardar cada uno en disco, en función del tipo de fichero y la función que elija.\n\n\n## Ficheros con columnas numéricas\n\nEmpiezo con el de todo numérico. Uso mi librería favorita, `microbenchmark`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nruntimes_numeric <- microbenchmark::microbenchmark(\n  csv_utils = write.csv(df_numeric, \"numeric_utils.csv\", row.names = FALSE),\n  csv_readr = write_csv(df_numeric, \"numeric_readr.csv\"),\n  fwrite = data.table::fwrite(df_numeric, \"numeric_fwrite.csv\"),\n  rds_base = base::saveRDS(df_numeric, \"numeric_base.rds\"),\n  rds_readr = readr::write_rds(df_numeric, \"numeric_readr.rds\"),\n  parquet = arrow::write_parquet(df_numeric, \"numeric.parquet\"),\n  feather = arrow::write_feather(df_numeric, \"numeric.feather\"),\n  times = 10L\n)\n```\n:::\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\nUnit: milliseconds\n      expr         min         lq       mean     median         uq        max\n csv_utils 202203.9288 266623.082 282231.496 281121.287 302487.454 331668.044\n csv_readr   9055.3445   9846.454  20284.347  10764.766  12634.343 104354.622\n    fwrite   1610.8502   8701.182   8911.451   9409.666  10717.019  11205.837\n  rds_base  25460.8486  26287.225  29357.257  28765.523  32329.897  35358.147\n rds_readr    330.9374   3041.022   3080.719   3132.418   3334.561   5672.141\n   parquet   3234.5500   8282.600   9649.330   9843.929  12261.475  12863.989\n   feather    410.0282   4370.313   4700.664   4539.408   5586.161   7597.147\n neval\n    10\n    10\n    10\n    10\n    10\n    10\n    10\n```\n:::\n:::\n\nVoy a visualizar esto (se puede hacer directamente sobre la salida de la función `microbenchmark()` pero lo paso a data frame porque he querido hacer algunas pruebas con las que necesitaba más control, aunque al final no las muestro aquí porque no aportan nada). \n\nCreo dos data frames para pintar los tiempos de cómputo y el tamaño de los ficheros. Los tiempos (milisegundos) vienen dados para ejecución: aquí están los primeros casos.\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\n       case       time\n1   feather   410.0282\n2    fwrite  1610.8502\n3 rds_readr   330.9374\n4   parquet  3234.5500\n5  rds_base 27254.9053\n6   feather  4436.2614\n7   feather  7597.1466\n```\n:::\n:::\n\n\nTomo también el tamaño de los ficheros generados:\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\n       size      case\n1 106522192  rds_base\n2 359999269    fwrite\n3 385418847 csv_readr\n4 160000514 rds_readr\n5 359998865 csv_utils\n6 133286834   feather\n7 143632169   parquet\n```\n:::\n:::\n\n\n\nCreo los gráficos por separado aunque se puede visualizar todo junto (pero me parece ganas de complicar). \n\nEstos son los tiempos de cómputo (quito `utils::write.csv()` porque ya sabemos que tarda mucho).\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](index_files/figure-html/plot-numeric-1.png){width=672}\n:::\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}