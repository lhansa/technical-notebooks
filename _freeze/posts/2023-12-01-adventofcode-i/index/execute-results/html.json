{
  "hash": "bd18a9d035348c9b93b3ee4282f139c0",
  "result": {
    "markdown": "---\ntitle: \"Advent of code (1)\"\ndescription: \"Ejercicio 1 de Advent of code 2023\"\ndescription-meta: \"Ejercicio 1 de Advent of code 2023\"\nauthor: \"Leonardo Hansa\"\ndate: \"2023-12-01\"\ncategories: [datos]\nexecute: \n  echo: false\nfreeze: auto\n---\n\n\nNunca he jugado con el [Advent of code](https://adventofcode.com/). Hoy me ha apetecido. \n\nPara el ejercicio de hoy, me he empeñado **en hacerlo en R base.**\n\n## Parte 1\n\nEl día 1 del [Advent of code 2023](https://adventofcode.com/2023) nos pide que sumemos los números que aparecen en un texto.\n\nEl texto tiene una pinta así: `\"four95qvkvveight5\"`, y hay 1.000 como ese. \n\nLa idea es: \n\n- tomar el primer dígito, 9, \n- y el último, 5\n- y concatenarlos: 95\n\nAsí obtendrás 1000 números. La solución es la suma de esos 1.000 números.\n\nMi propuesta:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata <- readLines(\"2023-01.txt\")\n\nget_number <- function(x) {\n  str_number <- gsub(\"[^0-9]\", \"\", x)\n  len <- nchar(str_number)\n  str_number <- paste0(substr(str_number, 1, 1), substr(str_number, len, len))\n  return(as.numeric(str_number))\n}\nnumbers <- vapply(\n  data, \n  get_number,\n  numeric(1)\n)\n\nsum(numbers)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 55208\n```\n:::\n:::\n\n\n## Parte 2\n\nAhora hay un matiz. Fíjate de nuevo en el texto: `\"four95qvkvveight5\"`. Realmente, el primer número es `\"four\"`, o sea, 4. Lo que hay que hacer ahora es identificar el primer dígito y el último pero tanto si viene en número como en texto. \n\nLuego igual, concatenarlos y sumarlos.\n\nMi propuesta: \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# a character vector with the numbers from zero to nine in letters\nwords <- c(\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\")\n\nsplit_words <- strsplit(words, \"\")\nwords_inv <- vapply(\n  split_words, \n  function(x) paste0(x[length(x):1], collapse = \"\"), \n  character(1)\n)\n\nwords_regex <- paste0(words, collapse = \"|\")\nwords_inv_regex <- paste0(words_inv, collapse = \"|\")\n\npattern <- paste(\"[0-9]\", words_regex, sep = \"|\")\npattern_inv <- paste(\"[0-9]\", words_inv_regex, sep = \"|\")\n\n# Change the order of a text\ninvert <- function(x) {\n  if (nchar(x) == 1) {\n    return(x)\n  } else {\n    return(paste0(strsplit(x, \"\")[[1]][nchar(x):1], collapse = \"\") )\n  }\n}\n\n# Convert a text to a number, based on the words and words_inv vectors\nto_numeric <- function(x, words = words, words_inv = words_inv) {\n  if (nchar(x) == 1) {\n    return(as.numeric(x))\n  } else if (x %in% words) {\n    return(which(words == x) - 1)\n  } else {\n    return(which(words_inv == x) - 1)\n  }\n}\n\nget_number2 <- function(x, \n                        pattern, \n                        pattern_inv,\n                        words, \n                        words_inv) {\n  \n  first <- regmatches(x, m = regexpr(pattern, x))\n  first <- to_numeric(first, words = words, words_inv = words_inv)\n  \n  x_inv <- invert(x)\n  last <- regmatches(x_inv, m = regexpr(pattern_inv, x_inv))\n  last <- invert(last)\n  last <- to_numeric(last, words = words, words_inv = words_inv)\n  \n  return(first * 10 + last)\n  \n}\n\n\nnumbers2 <- vapply(\n  data, \n  get_number2,\n  pattern = pattern,\n  pattern_inv = pattern_inv,\n  words = words, \n  words_inv = words_inv,\n  FUN.VALUE = numeric(1)\n)\n\nsum(numbers2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 54578\n```\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}