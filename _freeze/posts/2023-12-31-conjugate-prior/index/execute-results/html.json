{
  "hash": "9ad85c87641d0de3d42798f065ee084d",
  "result": {
    "markdown": "---\ntitle: \"¿Cómo se usan las prioris conjugadas?\"\ndescription: \"Tutorial en R de cómo usar las prioris conjugadas en estadística bayesiana, con el ejemplo de lanzar una moneda\"\ndescription-meta: \"Tutorial en R de cómo usar las prioris conjugadas en estadística bayesiana, con el ejemplo de lanzar una moneda\"\nauthor: \"Leonardo Hansa\"\ndate: \"2023-12-31\"\ncategories: [datos]\nexecute: \n  echo: true\nfreeze: auto\n---\n\n\nEn estadística bayesiana, cuando buscas estimar un parámetro, lo que vas a obtener es una distribución de este parámetro. O sea, no obtienes un valor preciso, sino unas probabilidades asociadas a varios valores, de forma que algunos serán más probables que otros. \n\nUn método intuitivo de conseguir esta distribución es usar el método del mallado ( _grid approximation_ ). Con este método, relacionas todos los casos posibles, calculas una verosimilitud para cada caso, y lo multiplicas por una probabilidad a priori que decidas. Ese producto es la distribución que buscas para tu parámetro, la posteriori. \n\nEn algunas situaciones, usar una priori en concreto te puede simplificar luego el cálculo, ya que no te hará falta aplicar los cálculos del mallado: puedes, pero el resultado será el mismo. \n\n## Prioris conjugados\n\nEn el caso de lanzar una moneda, estás trabajando con una binomial: tienes ciertos éxitos ante un número posible de casos. \n\nSi en este caso, usas como priori la distribución beta, entonces surgirá la magia. \n\nLa distribución es\n\n::: {.cell}\n\n```{.r .cell-code}\nmonedas <- 100\ncaras <- seq(0, monedas, 1)\np_cara <- seq(0, 1, 0.01)\nsample_size <- 1000\n\nbeta_alpha <- 2\nbeta_beta <- 10\nhist(rbeta(sample_size, beta_alpha, beta_beta), col = \"#800080\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/setup-1.png){width=672}\n:::\n\n```{.r .cell-code}\ndf <- as.data.frame(expand.grid(caras, p_cara))\nnames(df) <- c(\"caras\", \"p_cara\")\n```\n:::\n\n\nY podemos simular la posteriori con el método del mallado: \n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf$prior <- dbeta(df$p_cara, beta_alpha, beta_beta)\n# df$prior <- dunif(df$p_cara)\n\ndf$likelihood <- dbinom(df$caras, monedas, df$p_cara)\n\ndf$posteriori <- df$likelihood * df$prior\ndf$std_posteriori <- df$posteriori / sum(df$posteriori)\n\n\ncaras_observadas <- 70\nplot(df$p_cara[df$caras == caras_observadas], \n     df$posteriori[df$caras == caras_observadas] / sum(df$posteriori[df$caras == caras_observadas]), \n     type = \"o\", xlab = \"Probabilidad de cara\", ylab = \"Probabilidad\")\nlines(df$p_cara[df$caras == caras_observadas], \n      df$prior[df$caras == caras_observadas] / sum(df$prior[df$caras == caras_observadas]), \n      col = \"red\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/posterior1-1.png){width=672}\n:::\n:::\n\n\nLa magia está en que, dado que la distribución a priori es una beta, no necesitamos simular la posteriori, sino que sabemos que ya seguirá una distribución en concreto (una beta también, con pequeños cambios en sus parámetros);\n\n\n::: {.cell}\n\n```{.r .cell-code}\nposteriori_simulation <- dbeta(df$p_cara[df$caras == caras_observadas], \n                               beta_alpha + caras_observadas, \n                               beta_beta + monedas - caras_observadas)\n\nposteriori_simulation <- posteriori_simulation / sum(posteriori_simulation)\n\nplot(df$p_cara[df$caras == caras_observadas], \n     df$posteriori[df$caras == caras_observadas] / sum(df$posteriori[df$caras == caras_observadas]), \n     type = \"o\", xlab = \"Probabilidad de cara\", ylab = \"Probabilidad\")\nlines(df$p_cara[df$caras == caras_observadas], \n      df$prior[df$caras == caras_observadas] / sum(df$prior[df$caras == caras_observadas]), \n      col = \"red\")\nlines(df$p_cara[df$caras == caras_observadas], \n      posteriori_simulation, col = \"blue\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/posteriori-1.png){width=672}\n:::\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}