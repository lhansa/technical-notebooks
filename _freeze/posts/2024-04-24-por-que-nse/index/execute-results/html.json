{
  "hash": "09b232dc6cc8252bfdecc30e1b0bce69",
  "result": {
    "markdown": "---\ntitle: \"Por qué puedes necesitar non standard evaluation en dplyr\"\ndescription: \"Comparativa de non-stantard evaluation y tidyeval\"\ndescription-meta: \"Comparativa de non-stantard evaluation y tidyeval\"\nauthor: \"Leonardo Hansa\"\ndate: \"2024-04-24\"\ncategories: [datos]\nexecute: \n  echo: true\nmessage: false\nwarning: false\nfreeze: true\n---\n\n  \nTienes los datos de `penguins` y quieres hacer una función con el código de una exploración sobre este conjunto de datos. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_penguins <- palmerpenguins::penguins\ndf_penguins\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 344 × 8\n   species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n   <fct>   <fct>              <dbl>         <dbl>             <int>       <int>\n 1 Adelie  Torgersen           39.1          18.7               181        3750\n 2 Adelie  Torgersen           39.5          17.4               186        3800\n 3 Adelie  Torgersen           40.3          18                 195        3250\n 4 Adelie  Torgersen           NA            NA                  NA          NA\n 5 Adelie  Torgersen           36.7          19.3               193        3450\n 6 Adelie  Torgersen           39.3          20.6               190        3650\n 7 Adelie  Torgersen           38.9          17.8               181        3625\n 8 Adelie  Torgersen           39.2          19.6               195        4675\n 9 Adelie  Torgersen           34.1          18.1               193        3475\n10 Adelie  Torgersen           42            20.2               190        4250\n# ℹ 334 more rows\n# ℹ 2 more variables: sex <fct>, year <int>\n```\n:::\n:::\n\n\nLa situación que te planteo es que tienes que crear una función cuyo argumento sea el nombre de una de las columnas, y calcule la media de la longitud del pico (`bill_length_mm`) en función de esa columna. Con dplyr. \n\n## Planteamiento `tidyselect`\n\nUna forma de hacerlo, aceptando que el nombre de la columna venga como `character`, es esta: \n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\n\ncalcula_mediana_pico <- function(data, columna_grupos) {\n  data |> \n    group_by(pick(all_of(columna_grupos))) |> \n    summarise(mediana_long_pico = median(bill_length_mm, na.rm = TRUE))\n}\n\ndf_penguins |> \n  calcula_mediana_pico(\"island\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 2\n  island    mediana_long_pico\n  <fct>                 <dbl>\n1 Biscoe                 45.8\n2 Dream                  44.7\n3 Torgersen              38.9\n```\n:::\n:::\n\nLe pongo una pega. Puede haber más pero yo le pongo solo una: que tengo que entrecomillar la columna con la que agrupo. O sea, no puedo hacer esto: \n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_penguins |> \n  calcula_mediana_pico(island)\n# Error: object 'island' not found\n```\n:::\n\n\n## Planteamiento rlang\n\nMe gustaría que ese código funcionara, porque con dplyr es normal escribir los nombres de columnas sin comillas: \n\n- Puedes usar el autocompletado (con comillas no)\n- Va a ser consistente con otras funciones de dplyr\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_penguins |> \n  select(island, bill_length_mm, year) |> \n  filter(year > 2007) |> \n  calcula_mediana_pico(island)\n```\n:::\n\n\nEn un código como ese, no quiero tener que entrecomillar `island` porque no viene a cuento. \n\nEso lo puedo solucionar con rlang. La función quedará algo así:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(rlang)\n\ncalcula_mediana_pico <- function(data, columna_grupos) {\n  data |> \n    group_by(!!enquo(columna_grupos)) |> \n    summarise(mediana_long_pico = median(bill_length_mm, na.rm = TRUE))\n}\n```\n:::\n\n\nTe destripo ese ingrediente que acabo de poner. \n\n### `enquo`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nf <- function(argumento) {\n  enquo(argumento)\n}\n\nf(island)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<quosure>\nexpr: ^island\nenv:  global\n```\n:::\n:::\n\n\n`enquo()` me devuelve lo que se llama una _quosure_ (ni idea de su traducción): lo puedes ver como una expresión con información sobre el entorno.\n\nAl evaluar `enquo()` dentro de una función con un argumento, obtenemos el valor que se le ha dado al argumento sin llegar a evaluarlo: \n\n\n::: {.cell}\n\n```{.r .cell-code}\nf(1 + 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<quosure>\nexpr: ^1 + 1\nenv:  global\n```\n:::\n:::\n\n\nPara evaluarlo tenemos que: \n\n- Añadir el operador `!!` (_bang bang_). \n- Operar dentro de unas funciones determinadas, como muchas de dplyr.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nselecciona <- function(columna) {\n  df_penguins |> \n    select(!!enquo(columna))\n}\n\nselecciona(island) |> \n  slice_head(n = 6)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 1\n  island   \n  <fct>    \n1 Torgersen\n2 Torgersen\n3 Torgersen\n4 Torgersen\n5 Torgersen\n6 Torgersen\n```\n:::\n:::\n\n\nQue es justo lo que hacía en la función que te planteé más arriba: \n\n\n::: {.cell}\n\n```{.r .cell-code}\ncalcula_mediana_pico <- function(data, columna_grupos) {\n  data |> \n    group_by(!!enquo(columna_grupos)) |> \n    summarise(mediana_long_pico = median(bill_length_mm, na.rm = TRUE))\n}\n\ndf_penguins |> \n  calcula_mediana_pico(species)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 2\n  species   mediana_long_pico\n  <fct>                 <dbl>\n1 Adelie                 38.8\n2 Chinstrap              49.6\n3 Gentoo                 47.3\n```\n:::\n:::\n\n\nNi que decir tiene que es compatible con otras operaciones de dplyr: \n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_penguins |> \n  select(species, bill_length_mm, year) |> \n  filter(year > 2007) |> \n  calcula_mediana_pico(species) |> \n  arrange(desc(mediana_long_pico))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 2\n  species   mediana_long_pico\n  <fct>                 <dbl>\n1 Chinstrap              49.7\n2 Gentoo                 47.5\n3 Adelie                 38.7\n```\n:::\n:::\n\n\n\n> `!!enquo()` puede reemplazarse por el operador `{{}}` (_curly curly_), con el que tus códigos quedarán más limpios, aunque a mí no termina de gustarme porque creo que se enienden peor los elemenos de la librería rlang.\n\n### Más columnas\n\nVale, ahora no solo quieres dar al usuario la posibilidad de que dé la columna de agrupación, sino también la métrica que agregamos. \n\nSi solo quieres eso, no necesitas más ingredientes, pero ya verás cómo sí quieres tener otra cosa:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncalcula_mediana <- function(data, columna_grupos, metrica) {\n  data |> \n    group_by(!!enquo(columna_grupos)) |> \n    # cambio nombre de la mediana\n    summarise(mediana = median(!!enquo(metrica), na.rm = TRUE))\n}\n\ndf_penguins |> \n  calcula_mediana(species, bill_depth_mm)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 2\n  species   mediana\n  <fct>       <dbl>\n1 Adelie       18.4\n2 Chinstrap    18.4\n3 Gentoo       15  \n```\n:::\n:::\n\n\nGuay, ha funcionado. Puedo usar cualquier métrica y columna: \n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_penguins |> \n  calcula_mediana(year, flipper_length_mm)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 2\n   year mediana\n  <int>   <dbl>\n1  2007     195\n2  2008     200\n3  2009     199\n```\n:::\n:::\n\nLo que me falta ahora es poder cambiar el nombre también de la columna mediana en función de la métrica elegida. \n\n### `:=` y `as_name`\n\nLa intuición podría decirte que hicieras algo parecido a la izquierda del igual, con `!!enquo()`. No te va a funcionar, salvo que añadas el operador. `:=`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncalcula_mediana <- function(data, columna_grupos, metrica) {\n  data |> \n    group_by(!!enquo(columna_grupos)) |> \n    # cambio nombre de la mediana\n    summarise(!!enquo(metrica) := median(!!enquo(metrica), na.rm = TRUE))\n}\n\ndf_penguins |> \n  calcula_mediana(island, bill_depth_mm)\n```\n:::\n\nUn pequeño cambio y lo solucionas todo. \n\nPero vamos incluso un paso más allá. Quieres que la métrica nueva no se llame igual que la columna que agregas sino `\"mediana_\"` pegado al nombre de la columna. Para eso necesitas la combinación de `as_name()`, que te va a permitir tratar como `character` el argumento que pasa el usuario: \n\n\n::: {.cell}\n\n```{.r .cell-code}\nas_name(quote(bill_length_mm))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"bill_length_mm\"\n```\n:::\n:::\n\n\nVamos a aplicar esto: \n\n\n::: {.cell}\n\n```{.r .cell-code}\ncalcula_mediana <- function(data, columna_grupos, metrica) {\n  nuevo_nombre <- paste0(\n    \"mediana_\", \n    as_name(enquo(metrica))\n  )\n  data |> \n    group_by(!!enquo(columna_grupos)) |> \n    summarise(!!nuevo_nombre := median(!!enquo(metrica), na.rm = TRUE))\n}\n\ndf_penguins |> \n  calcula_mediana(island, bill_depth_mm)\n```\n:::\n\n\nO: \n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_penguins |> \n  calcula_mediana(year, body_mass_g)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 2\n   year mediana\n  <int>   <dbl>\n1  2007    3900\n2  2008    4200\n3  2009    4000\n```\n:::\n:::\n\n\n\n***\n\nComo decía más arriba, `!!enquo()` se puede reemplazar por `{{}}`, pero creo que dificulta ver el papel de `enquo()` en todo esto.\n\n***\n\nAtención: \n\n\n::: {.cell}\n\n```{.r .cell-code}\nnuevo_entorno <- new.env()\nnuevo_entorno$`+` <- `-`\n\nsuma_expr <- expr(1 + 1)\nsuma_expr\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1 + 1\n```\n:::\n:::\n\n\nY resulta que: \n\n::: {.cell}\n\n```{.r .cell-code}\neval_tidy(suma_expr, env = nuevo_entorno)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0\n```\n:::\n:::\n\n\n¿O no?\n\n::: {.cell}\n\n```{.r .cell-code}\neval_tidy(suma_expr)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2\n```\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}