{
  "hash": "028e1c93ebcf803098f2a8e1eef00ec7",
  "result": {
    "markdown": "---\ntitle: \"Un problema habitual en ficheros CSV\"\ndescription: \"El formato de los ficheros CSV depende de cómo se separen las columnas y de cómo se indique la separación decimal. ues hay una mezcla horrorosa que no tiene ningún sentido.\"\ndescription-meta: \"Cómo leer ficheros CSV que te dan problemas\"\nauthor: \"Leonardo Hansa\"\ndate: \"2024-05-09\"\ncategories: [datos]\nexecute: \n  echo: true\nmessage: false\nwarning: false\nfreeze: true\n---\n\n::: {.cell python.reticulate='false'}\n\n:::\n\n\nTienes el conjunto de datos _iris_ en un fichero de texto plano con esta pinta: \n\n```\nsepal length (cm);sepal width (cm);petal length (cm);petal width (cm);species\n5.1;3.5;1.4;0.2;0;1,000.23\n4.9;3.0;1.4;0.2;0;1,000.23\n4.7;3.2;1.3;0.2;0;1,000.23\n4.6;3.1;1.5;0.2;0;1,000.23\n5.0;3.6;1.4;0.2;0;1,000.23\n5.4;3.9;1.7;0.4;0;1,000.23\n```\n\nComo verás, lo he tuneado un poco: le he añadido una columna con valor constante 1000.23, escrito con el formato anglosajón de separador de miles usando comas.\n\nMaravilloso. A ver cómo lo leemos.\n\n## R\n\nEn R, puedes tener la tentación de leerlo así: \n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(readr)\ndf_iris <-  read_csv(\"iris.txt\")\ndf_iris\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 150 × 1\n   sepal length (cm);sepal width (cm);petal length (cm);petal width (cm);speci…¹\n   <chr>                                                                        \n 1 5.1;3.5;1.4;0.2;0;1,000.23                                                   \n 2 4.9;3.0;1.4;0.2;0;1,000.23                                                   \n 3 4.7;3.2;1.3;0.2;0;1,000.23                                                   \n 4 4.6;3.1;1.5;0.2;0;1,000.23                                                   \n 5 5.0;3.6;1.4;0.2;0;1,000.23                                                   \n 6 5.4;3.9;1.7;0.4;0;1,000.23                                                   \n 7 4.6;3.4;1.4;0.3;0;1,000.23                                                   \n 8 5.0;3.4;1.5;0.2;0;1,000.23                                                   \n 9 4.4;2.9;1.4;0.2;0;1,000.23                                                   \n10 4.9;3.1;1.5;0.1;0;1,000.23                                                   \n# ℹ 140 more rows\n# ℹ abbreviated name:\n#   ¹​`sepal length (cm);sepal width (cm);petal length (cm);petal width (cm);species;extra`\n```\n:::\n:::\n\n\nTodo horrible porque está todo dentro de una columna. La función no ha sabido separar en columnas porque esperaba la coma como delimitador. La coma está en los valores de la columna `extra` pero no en la primera fila, con los nombres de columnas. Así que `read_csv` entiende que solo hay una columna. \n\n`read.csv()` se hace bastante lío y daría error con algo así.\n\nUn clásico cuando no te funciona `read_csv()` es probar `read_csv2()`, que asume que la separación es `\";\"`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_iris <-  read_csv2(\"iris.txt\")\nhead(df_iris)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 6\n  `sepal length (cm)` `sepal width (cm)` `petal length (cm)` `petal width (cm)`\n                <dbl>              <dbl>               <dbl> <chr>             \n1                  51                 35                  14 0.2               \n2                  49                 30                  14 0.2               \n3                  47                 32                  13 0.2               \n4                  46                 31                  15 0.2               \n5                  50                 36                  14 0.2               \n6                  54                 39                  17 0.4               \n# ℹ 2 more variables: species <dbl>, extra <dbl>\n```\n:::\n:::\n\nTampoco funciona. \n\nLas columnas sí están separadas, pero los valores no tienens sentido. `read_csv2()` ha usado la coma como separador decimal. Y los puntos que había en los números, se los ha pasado por ahí. Y la columna `extra` la ha puesto como si la coma fuera el separador decimal, cuando realmente es el separador de miles.\n\nAsí que mal.\n\nSi usaras R base con `read.csv2()` tendrías también un poco de lío, con columnas identificadas como texto en lugar de número. \n\n\nEn estos casos, yo tiro de `readr::read_delim()` especificando cuál es el separador de miles y cuál el decimal (algo equivalente puedes hacer en R base con `read.table()`).\n\nCon la función `readr::locale()` especifico estos separadores.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_iris <- read_delim(\"iris.txt\", delim = \";\", locale = locale(decimal_mark = \".\", grouping_mark = \",\"))\nhead(df_iris)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 6\n  `sepal length (cm)` `sepal width (cm)` `petal length (cm)` `petal width (cm)`\n                <dbl>              <dbl>               <dbl>              <dbl>\n1                 5.1                3.5                 1.4                0.2\n2                 4.9                3                   1.4                0.2\n3                 4.7                3.2                 1.3                0.2\n4                 4.6                3.1                 1.5                0.2\n5                 5                  3.6                 1.4                0.2\n6                 5.4                3.9                 1.7                0.4\n# ℹ 2 more variables: species <dbl>, extra <dbl>\n```\n:::\n:::\n\n\nEs un esperpento anti-estandarizaciones, pero ocurre. Debe de haber algunas herramientas de estas que descargan informes en texto plano que tienen esta configuración horrorosa, porque me llegan ficheros así cada dos por tres. \n\nY como no son estándar, las funciones habituales de lectura de CSVs se hacen bastante lío.\n\nPara casos así, intento **ser muy explícito con el código** y `read_delim()` me obliga a ello por sistema. \n\n## Con Python\n\nEn Python usaría directamente la función de pandas `pd.read_csv()` especificando todo.\n\nPor defecto no funciona:\n\n\n::: {.cell python.reticulate='false'}\n\n```{.python .cell-code}\nimport pandas as pd\ndf_iris = pd.read_csv('iris.txt')\ndf_iris.head()\n```\n:::\n\nPero cada cosa tiene su argumento:\n\n\n::: {.cell python.reticulate='false'}\n\n```{.python .cell-code}\nimport pandas as pd\ndf_iris = pd.read_csv(\n  'iris.txt', \n  sep=';', \n  decimal='.', #no necesario en este caso\n  thousands=','\n  \n  )\ndf_iris.head()\n```\n:::\n\n\nLa función `pd.read_csv()` ya asume que el separador decimal es el punto, así que no hace falta especificar nada de eso esta vez... \n\n  ",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}