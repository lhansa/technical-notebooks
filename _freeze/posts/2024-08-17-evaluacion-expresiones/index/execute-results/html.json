{
  "hash": "38fab48cb066891e34cbd5fb558c16cd",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Evaluación de expresiones en R\"\ndescription: \"Tutorial sobre evaluación manual de expresiones en R con rlang\"\ndescription-meta: \"Tutorial sobre evaluación manual de expresiones en R con rlang\"\nauthor: \"Leonardo Hansa\"\ndate: \"2024-08-17\"\ncategories: [datos]\nexecute: \n  echo: true\n  message: false\n  warning: false\nfreeze: true\n---\n\n\n\nLevanta la mano si a ti también te gusta concatenar caracteres con `+` como en Python. \n\nMe refiero a que en Python puedes hacer `'Hola ' + ' Leo'` pero en R no. \n\n¿O sí?\n\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n\"hola, puedo \" + \"concatenar\"\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"hola, puedo concatenar\"\n```\n\n\n:::\n:::\n\n\n\nPero:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n1 + 3\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4\n```\n\n\n:::\n:::\n\n\n\n## Justificación de `quosures`\n\nLa idea detrás de funciones como `base::subset()` o `dplyr::mutate()` es que puedes escribir operaciones dentro de data frames haciendo referencia directamente a las columnas, sin usar la sintaxis `df$columna`. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(rlang)\nopera <- function(data, entrada) {\n  eval_tidy(enexpr(entrada), data)\n}\n\nnuevo_calculo <- opera(iris, Sepal.Length + Sepal.Width)\nhead(nuevo_calculo)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 8.6 7.9 7.9 7.7 8.6 9.3\n```\n\n\n:::\n:::\n\n\n\nEl inconveniente es que `enexpr()` puede no ser suficiente porque no tiene en cuenta información del entorno.\n\nPor ejemplo: \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- data.frame(col1 = c(5, 6, 7))\nfactor <- 2\n\nopera2 <- function(data, entrada) {\n  factor <- 10\n  eval_tidy(enexpr(entrada), data)\n}\n\n# Con enquo no sabes cuál es el entorno original de la variable\nopera2(df, col1 * factor)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 50 60 70\n```\n\n\n:::\n:::\n\n\n\nUna solución que se te puede ocurrir es: _no pongas en la expresión variables que estén definidas en la función_. Ya, ¿y si no sabes lo que hay en la función? ¿Y si el código es tan largo que no te da para revisarlo?\n\nPues lo arreglas con `enquo()`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- data.frame(col1 = c(5, 6, 7))\nfactor <- 2\n\nopera3 <- function(data, entrada) {\n  factor <- 10\n  eval_tidy(enquo(entrada), data)\n}\n\n# Con enquo usas el entorno donde se definió la variable original\nopera3(df, col1 * factor)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 10 12 14\n```\n\n\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}