{
  "hash": "7af0036603e5b826928d93a77a2c0d3e",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Introducción práctica a Rust\"\ndescription: \"Alguna prueba con Rust y su interacción con R y Python\"\ndescription-meta: \"Alguna prueba con Rust y su interacción con R y Python\"\nauthor: \"Leonardo Hansa\"\ndate: \"2024-09-08\"\ncategories: [datos]\nexecute: \n  echo: true\n  message: false\n  warning: false\nfreeze: true\n---\n\n\n\nNo tengo ni idea de Rust, pero he oído que es muy rápido y gestiona la RAM de manera más automática que C++. C++ es fácil de aprovechar con R para utilizar su velocidad pero me tienta probar cosas nuevas. \n\nPara usar R y Rust [he leído](https://extendr.github.io/rextendr/) sobre el paquete **rextendr**.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(rextendr)\n\n# create a Rust function\nrust_function(\"fn add(a:f64, b:f64) -> f64 { a + b }\")\n\n# call it from R\nadd(2.5, 4.7)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 7.2\n```\n\n\n:::\n:::\n\n\n\nEse código básico funciona. Se ha creado un objeto nuevo `add` que es de tipo `function`.\n\n## Cálculo de R2 con Rust\n\nAhora creo una función que, dados dos vectores, calcule el R2 de ambos, como si uno fuese la predicción que un modelo hace para el otro.\n\n**Observación.** Yo no sé Rust pero ChatGPT y otras IIAA sí saben.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncode <- r\"(\n    #[extendr]\n    fn calcula_r2_rust(actual: &[f64], predicted: &[f64]) -> f64 {\n     \n        let n = actual.len() as f64;\n        let mean_actual = actual.iter().sum::<f64>() / n;\n\n        let ssr = actual.iter().enumerate().map(|(i, x)| (x - predicted[i]).powi(2)).sum::<f64>();\n        let sst = actual.iter().map(|(x)| (x - mean_actual).powi(2)).sum::<f64>();\n        1.0 - ssr / sst\n    \n    }\n)\"\nrust_source(\n    code = code, \n)\n```\n:::\n\n\n\n\n\nAhora me invento unos _datos_ y aplico la función.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnsize <- 1e6\nvalor_real <- rnorm(nsize, 10, 1)\nvalor_pred <- valor_real + rnorm(nsize, 0, 0.5)\n\ncalcula_r2_rust(valor_real, valor_pred)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.7492446\n```\n\n\n:::\n:::\n\n\n\n\n## Comparativa de tiempos de ejecución \nCreo una función para calcular eso mismo con R.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncalcula_r2_r <- function(actual, pred) {\n    numerador <- sum((actual - pred) ^ 2)\n    mean_actual <- mean(actual)\n    denominador <- sum((actual - mean_actual) ^ 2)\n\n    1 - numerador / denominador\n}\n\ncalcula_r2_r(valor_real, valor_pred)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.7492446\n```\n\n\n:::\n:::\n\n\n\nY ahora lo divertido, comparo tiempos. Que, por supuesto, no tienen ningún sentido. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmicrobenchmark::microbenchmark(\n    rust = calcula_r2_rust(valor_real, valor_pred), \n    r = calcula_r2_r(valor_real, valor_pred)\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nUnit: milliseconds\n expr      min       lq     mean   median       uq      max neval\n rust 60.86050 62.41938 67.36861 64.71865 72.43868 86.67186   100\n    r 16.77276 17.47662 24.79657 23.71143 30.52387 50.23770   100\n```\n\n\n:::\n:::\n\n\n\n\nYa, otro día comparo con Rcpp y lo llevo a Python.",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}