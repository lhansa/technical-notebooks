{
  "hash": "e0a808a3a3e8631fde9e094bccc95202",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Quita caracteres raros en tus variables (2)\"\ndescription: \"Pequeña práctica para limpiar los textos de las variables de tus tablas con Python\"\ndescription-meta: \"Pequeña práctica para limpiar los textos de las variables de tus tablas con Python\"\nauthor: \"Leonardo Hansa\"\ndate: \"2024-10-31\"\ncategories: [exploraciones]\nexecute: \n  echo: true\n  message: false\n  warning: false\nfreeze: true\n---\n\n\nEl otro día [te compartí ideas](https://lhansa.github.io/posts/2024-10-18-quita-caracteres-raros-en-tus-variables/) de cómo adaptar valores de texto que no te sirven como nombres de columnas. En R. \n\n[José Luis Cañadas](https://muestrear-no-es-pecado.netlify.app/) me habló de la librería **pyjanitor** como alternativa en Python. Me sonaba lejanamente pero nunca la había usado. \n\nAporta muchas más cosas aparte de cambiar textos para que cumplan con ciertas reglas de estilo. En cierto modo te da toda una nueva sintaxis para hacer las operaciones que haces con pandas de una forma más parecida al **tidyverse**. \n\nAhora mismo no es lo busco. Lo que busco es replicar el ejercicio del otro día. \n\nAsí que vamos a ello. \n\n## `pyjanitor`\n\n::: {#libs .cell execution_count=1}\n``` {.python .cell-code}\nimport pandas as pd\nimport janitor\n```\n:::\n\n\nTeníamos un listado de nombres que en un proyecto real vendrían como valores de la columna de un data frame. Y están repetidos.\n\n::: {#01091ce0 .cell execution_count=2}\n``` {.python .cell-code}\nnombres = [\"Campaña veintitrés\", \"C'est très petite\", \"Alışveriş Arabası Önü Giydirme\"]\nnombres = nombres * 2\nnombres\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n```\n['Campaña veintitrés',\n \"C'est très petite\",\n 'Alışveriş Arabası Önü Giydirme',\n 'Campaña veintitrés',\n \"C'est très petite\",\n 'Alışveriş Arabası Önü Giydirme']\n```\n:::\n:::\n\n\nQueremos reescribirlos para que sigan un estilo válido como nombres de columnas. Este estilo es opinable, pero para ir al grano asumiré que  lo que quiero es esto: \n\n- _snake case_, es decir, todo en minúscula con palabras separadas por barras bajas. \n- Sin tildes, ni eñes ni otros caracteres raros (donde raro es no anglosajón). \n- ... Y más cosas que ahora me dan igual. \n\nLa librería janitor está pensada para trabajar directamente con un data frame. Pero no es lo que busco ahora. Es más: la funcionalidad de limpiar valores de una columna (no nombres) ni siquiera está a mano. \n\n## La función escondida\n\nHe [curioseado el código fuente](https://github.com/pyjanitor-devs/pyjanitor/blob/dev/janitor/functions/clean_names.py) y he encontrado la función que limpia los nombres de las columnas, es decir, el código que aplica las reglas de limpieza. \n\nEste código está un poco escondido, pero lo puedes llamar directamenmte sobre una serie de pandas (es decir, lo que podría llegar a ser una columna de un data frame).\n\nLa función es `_clean_names` y su primer argumento es la serie que quieres editar. Ninguno de los argumentos de configuración tiene valor por defecto, así que hay que especificarlos todos. \n\n::: {#94aa650a .cell execution_count=3}\n``` {.python .cell-code}\nfrom janitor.functions.clean_names import _clean_names\n\nnombres = pd.Series(nombres)\nnuevos_nombres = _clean_names(\n    nombres,\n    strip_underscores=True, \n    case_type='snake', \n    remove_special=True, \n    strip_accents=True, \n    enforce_string=True, \n    truncate_limit=False)\n\nnuevos_nombres\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```\n0            campaa_veintitrs\n1             cest_trs_petite\n2    alveri_arabas_n_giydirme\n3            campaa_veintitrs\n4             cest_trs_petite\n5    alveri_arabas_n_giydirme\ndtype: object\n```\n:::\n:::\n\n\nNo queda igual que en el caso de R (por ejemplo, las eñes las quita pero no las convierte a enes) pero para lo que quiero hacer aquí me vale.\n\nGracias, José Luis, como siempre, que incluso con Python me ayudas.\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}