{
  "hash": "52946ac24a4a4624d24ebcdb349d696a",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Tiempos de lectura de un fichero Excel\"\ndescription: \"Ejercicio de exploración de tiempos de lectura de un fichero Excel\"\ndescription-meta: \"Ejercicio de exploración de tiempos de lectura de un fichero Excel\"\nauthor: \"Leonardo Hansa\"\ndate: \"2025-03-11\"\ncategories: [exploraciones]\nexecute: \n  echo: true\n  message: false\n  warning: false\nfreeze: true\n---\n\n\n\nVoy a intentar mejorar el tiempo de lectura de un fichero Excel. \n\n## Preparación de datos\n\nNo tengo ninguno a mano, así que me lo invento. Genero un data frame con 1000 filas y 100 columnas y lo guardo en un fichero Excel.\n\nLas columnas serán de distintos tipos: \n\n- Las 10 primeras columnas serán de tipo fecha. \n- Las 10 columnas siguientes serán de tipo entero.\n- Las 10 columnas siguienets serán de tipo character. \n- Las demás columnas serán de tipo numérico.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(123)\n\nn <- 10000\nm <- 100\n\ndf_fechas <- data.frame(\n  lapply(1:10, function(i) {\n    as.Date(\"2025-01-01\") + sample(1:1000, n, replace = TRUE)\n  })\n)\n\nnames(df_fechas) <- paste0(\"fecha_\", 1:10)\n\ndf_enteros <- data.frame(\n  lapply(1:10, function(i) {\n    sample(1:1000, n, replace = TRUE)\n  })\n)\n\nnames(df_enteros) <- paste0(\"entero_\", 1:10)\n\ndf_caracter <- data.frame(\n  lapply(1:10, function(i) {\n    sample(letters, n, replace = TRUE)\n  })\n)\n\nnames(df_caracter) <- paste0(\"caracter_\", 1:10)\n\ndf_numericos <- data.frame(\n  lapply(1:(m - 30), function(i) {\n    rnorm(n)\n  })\n)\n\nnames(df_numericos) <- paste0(\"numerico_\", 1:(m - 30))\n\ndf <- cbind(df_fechas, df_enteros, df_caracter, df_numericos)\n\nwritexl::write_xlsx(df, \"~/Desktop/datos.xlsx\")\n```\n:::\n\n::: {.cell}\n\n:::\n\n\n\n## Prueba 1\n\nAhora leo el fichero Excel con la función `readxl::read_xlsx` y cuento tiempos.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(microbenchmark)\nlibrary(readxl)\n\nmicrobenchmark(\n  excel = readxl::read_excel(\"~/Desktop/datos.xlsx\"),\n  xlsx = readxl::read_xlsx(\"~/Desktop/datos.xlsx\"),\n  times = 10\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nUnit: milliseconds\n  expr      min       lq     mean   median       uq       max neval\n excel 817.9462 825.5456 866.1293 848.6167 910.4109  959.5712    10\n  xlsx 818.2618 834.9224 940.5163 851.6510 939.8498 1496.9993    10\n```\n\n\n:::\n:::\n\n\n\nFlipo por primera vez porque dejar que averigüe la extensión es más rápido que especificársela.\n\n## Prueba 2\n\nAhora intento acelerar esto. Una opción es usar la función `readxl::read_xlsx` con el argumento `guess_max`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmicrobenchmark(\n  xlsx_1000 = readxl::read_xlsx(\"~/Desktop/datos.xlsx\"),\n  xlsx_10 = readxl::read_xlsx(\"~/Desktop/datos.xlsx\", guess_max = 10),\n  times = 10\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nUnit: milliseconds\n      expr      min       lq     mean   median       uq       max neval\n xlsx_1000 820.7639 833.2358 909.8336 886.4963 974.2052 1078.0520    10\n   xlsx_10 820.3404 837.1177 881.2103 846.8810 937.2429  976.9624    10\n```\n\n\n:::\n:::\n\n\n\nFlipo por segunda vez porque dejar que adivine con 10 filas es más lento que dejarle que adivine con 1000.\n\n## Prueba 3\n\nAhora voy a especificar los tipos de columnas en el argumento col_types. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncol_types <- c(\n  rep(\"date\", 10),\n  rep(\"numeric\", 10),\n  rep(\"text\", 10),\n  rep(\"numeric\", m - 30)\n)\n\nmicrobenchmark(\n  xlsx_1000 = readxl::read_xlsx(\"~/Desktop/datos.xlsx\"),\n  xlsx_col_types = readxl::read_xlsx(\"~/Desktop/datos.xlsx\", col_types = col_types),\n  times = 10\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nUnit: milliseconds\n           expr      min       lq     mean   median       uq       max neval\n      xlsx_1000 817.4203 825.1557 861.3388 839.0177 874.1154  980.9381    10\n xlsx_col_types 818.4011 831.7859 891.1541 843.5541 956.0038 1076.8263    10\n```\n\n\n:::\n:::\n\n\n\n\nY me quedo flipando aún más porque lo de especificar `col_types` apenas ayuda (de hecho, si el número de filas es 1000 en lugar de 10000, empeora el tiempo; por lo menos, en una prueba que he hecho pero no he publicado).\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}