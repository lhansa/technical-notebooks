{
  "hash": "a48a57fdc249aa39447df590e11c5788",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Tiempos de lectura de un fichero Excel\"\ndescription: \"Ejercicio de exploración de tiempos de lectura de un fichero Excel\"\ndescription-meta: \"Ejercicio de exploración de tiempos de lectura de un fichero Excel\"\nauthor: \"Leonardo Hansa\"\ndate: \"2025-03-11\"\ncategories: [exploraciones]\nexecute: \n  echo: true\n  message: false\n  warning: false\nfreeze: true\n---\n\n\n\nVoy a intentar mejorar el tiempo de lectura de un fichero Excel. \n\n## Preparación de datos\n\nNo tengo ninguno a mano, así que me lo invento. Genero un data frame con 1000 filas y 100 columnas y lo guardo en un fichero Excel.\n\nLas columnas serán de distintos tipos: \n\n- Las 10 primeras columnas serán de tipo fecha. \n- Las 10 columnas siguientes serán de tipo entero.\n- Las 10 columnas siguienets serán de tipo character. \n- Las demás columnas serán de tipo numérico.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(123)\n\nn <- 10000\nm <- 100\n\ndf_fechas <- data.frame(\n  lapply(1:10, function(i) {\n    as.Date(\"2025-01-01\") + sample(1:1000, n, replace = TRUE)\n  })\n)\n\nnames(df_fechas) <- paste0(\"fecha_\", 1:10)\n\ndf_enteros <- data.frame(\n  lapply(1:10, function(i) {\n    sample(1:1000, n, replace = TRUE)\n  })\n)\n\nnames(df_enteros) <- paste0(\"entero_\", 1:10)\n\ndf_caracter <- data.frame(\n  lapply(1:10, function(i) {\n    sample(letters, n, replace = TRUE)\n  })\n)\n\nnames(df_caracter) <- paste0(\"caracter_\", 1:10)\n\ndf_numericos <- data.frame(\n  lapply(1:(m - 30), function(i) {\n    rnorm(n)\n  })\n)\n\nnames(df_numericos) <- paste0(\"numerico_\", 1:(m - 30))\n\ndf <- cbind(df_fechas, df_enteros, df_caracter, df_numericos)\n\nwritexl::write_xlsx(df, \"~/Desktop/datos.xlsx\")\n```\n:::\n\n\n\n## Prueba 1\n\nAhora leo el fichero Excel con la función `readxl::read_xlsx` y cuento tiempos.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(microbenchmark)\nlibrary(readxl)\n\nmicrobenchmark(\n  excel = readxl::read_excel(\"~/Desktop/datos.xlsx\"),\n  xlsx = readxl::read_xlsx(\"~/Desktop/datos.xlsx\"),\n  times = 10\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nUnit: seconds\n  expr      min       lq     mean   median       uq      max neval\n excel 1.302204 1.313330 1.405261 1.331752 1.555194 1.612290    10\n  xlsx 1.300124 1.314986 1.492864 1.438643 1.539966 1.968285    10\n```\n\n\n:::\n:::\n\n\n\nFlipo por primera vez porque dejar que averigüe la extensión es más rápido que especificársela.\n\n## Prueba 2\n\nAhora intento acelerar esto. Una opción es usar la función `readxl::read_xlsx` con el argumento `guess_max`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmicrobenchmark(\n  xlsx_1000 = readxl::read_xlsx(\"~/Desktop/datos.xlsx\"),\n  xlsx_10 = readxl::read_xlsx(\"~/Desktop/datos.xlsx\", guess_max = 10),\n  times = 10\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nUnit: seconds\n      expr      min       lq     mean   median       uq      max neval\n xlsx_1000 1.258093 1.295654 1.434211 1.328994 1.589370 1.871394    10\n   xlsx_10 1.272910 1.330283 1.377046 1.345380 1.377045 1.722568    10\n```\n\n\n:::\n:::\n\n\n\nFlipo por segunda vez porque dejar que adivine con 1000 filas es más rápido que dejarle que adivine con menos.\n\n## Prueba 3\n\nAhora voy a especificar los tipos de columnas en el argumento col_types. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncol_types <- c(\n  rep(\"date\", 10),\n  rep(\"numeric\", 10),\n  rep(\"text\", 10),\n  rep(\"numeric\", m - 30)\n)\n\nmicrobenchmark(\n  xlsx_1000 = readxl::read_xlsx(\"~/Desktop/datos.xlsx\"),\n  xlsx_col_types = readxl::read_xlsx(\"~/Desktop/datos.xlsx\", col_types = col_types),\n  times = 10\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nUnit: seconds\n           expr      min       lq     mean   median       uq      max neval\n      xlsx_1000 1.258791 1.276888 1.313231 1.313837 1.333304 1.367563    10\n xlsx_col_types 1.266509 1.279072 1.357004 1.291874 1.370188 1.785801    10\n```\n\n\n:::\n:::\n\n\n\n\nY me quedo flipando aún más porque lo de especificar `col_types` apenas ayuda (de hecho, si el número de filas es 1000 en lugar de 10000, empeora el tiempo; por lo menos, en una prueba que he hecho pero no he publicado).\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}